# 剪绳子

给你一根长度为 *n* 绳子，请把绳子剪成 *m* 段（*m*、*n* 都是整数，2 ≤ *n* ≤ 58 并且  *m* ≥ 2）。

每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？

例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

#### 样例

```
输入：8

输出：18
```

## 思路

O(n)

證明：

首先把一個正整數 N 拆分若干個正整數只有有限種拆法，所以存在最大乘積。

假設 N = n1 + n2 + … + nk，并且 n1 * n2 * … * nk 是最大乘積。

1. 顯然不會出現 1 在其中，因為 ( N - 1 ) * 1 < N，所以減去 1 後得出的結果會比原本小。
2. 如果對於某個 i 有 ni >= 5 ，那麼把 ni 拆分成 3 + ( ni - 3 )，我們有 

```
3(ni - 3) = 3ni - 9 > ni => 2ni > 9 ，當 ni 為 5 時，有2 * 5 ＝ 10 > 9
```

3. 如果 ni = 4 ，拆成 2 + 2 乘積不變，所以不妨假設沒有 4 。
4. 肯定沒有超個三個或以上的 2 ，因為如果有三個或以上的 2 ，那麼 3 * 3 > 2 * 2 * 2 ，所以替換成 3 乘積更大。

綜上，選用䀆量多的 3 ，直到剩下 2 或者 4 時，用 2 。

時間複雜度分析：當 n 比較大時，n 會被拆分成 ⌈n/3⌉ 個數，我們需要計算這麼多次減法和乘法，所以時間複雜度是O(n)。